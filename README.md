# Fucking algorithms...
### **Lab1:**
  -  [first](https://github.com/necha143/algorithms/blob/main/lab1/1.py) <br />
  -  [second](https://github.com/necha143/algorithms/blob/main/lab1/2.py) <br />
  -  [Fridge](https://github.com/necha143/algorithms/blob/main/lab1/holodosAISD.py) <br />
### **Lab2:** 
  -   Требуется вставить в данный массив на данное место данный элемент, сдвинув остальные элементы вправо:  <br />
     [insert numb](https://github.com/necha143/algorithms/blob/main/lab2/insert_numb.cpp) <br />
  -   Требуется отсортировать массив по неубыванию методом "вставок":  <br />
     [**INSERT-SORT**](https://github.com/necha143/algorithms/blob/main/lab2/Insert_Sort.cpp) <br />
  -   Задача про месклинитов и их плоты...:  <br />
     [expedition](https://github.com/necha143/algorithms/blob/main/lab2/expedition.cpp) <br />
  -   Продемонтрировать работу метода "вставок":  <br />
     [library method](https://github.com/necha143/algorithms/blob/main/lab2/library_method.cpp) <br />
  -   Во время олимпиады участники получили id и идентификаторы. Необходимо отсортировать список участников олимпиады по количеству набранных баллов и id:  <br />
     [olimpyad results](https://github.com/necha143/algorithms/blob/main/lab2/olimpiad_results.py) <br />
  -   Отсортируйте массив, используя сортировку слиянием:  <br />
     [**MERGE-SORT**](https://github.com/necha143/algorithms/blob/main/lab2/Merge_Sort.cpp) <br />
  -  Назовем два массива похожимы, если они состоят из одних и тех же элементов. По двум массивам выясните, похожие они или нет:  <br />
     [similar arrays](https://github.com/necha143/algorithms/blob/main/lab2/similar_arrays.cpp) <br />
  -   Каждый друг покрасил несколько идущих подряд досок, при это некоторые доски могли быть покрашены несколько раз, а какие-то вовсе нет. Выясните общее количество покрашенных досок:  <br />
     [fence](https://github.com/necha143/algorithms/blob/main/lab2/fence.cpp) <br />
  -  Отсортируйте массив, используя быструю сортировку:  <br />
     [**QUICK-SORT**](https://github.com/necha143/algorithms/blob/main/lab2/Quick_Sort.cpp) <br />
  -  Программа, генерирующая тест, на котором быстрая сортировка делает наибольшее число таких сравнений:  <br />
     [**anti_quick-sort**](https://github.com/necha143/algorithms/blob/main/lab2/Anti_Q_Sort.cpp) <br />
  -  Дан массив из n элементов. Какое число к-ое в порядке возрастания в этом массиве?:  <br />
     [**k'th order statistic**](https://github.com/necha143/algorithms/blob/main/lab2/Kats_poryad_stats.cpp) <br />
### **Lab3:**
  -  Реализуйте работу очереди. Для каждой операции изъятия элемента выведите её результат: <br />
     [**QUEUE**](https://github.com/necha143/algorithms/blob/main/lab3/Queue.cpp) <br />
  -  Реализуйте работу стека. Для каждой операции изъяятия элемента выведите её результат: <br />
     [**STAK**](https://github.com/necha143/algorithms/blob/main/lab3/Stak.cpp) <br />
  -  Правильная скобочная последовательность: <br />
     [**brackets**](https://github.com/necha143/algorithms/blob/main/lab3/Right_brackets.cpp) <br />
  -  Постфикнсная запись (или обратная польская запись):  <br />
     [**postfix**](https://github.com/necha143/algorithms/blob/main/lab3/Postfix.cpp) <br />
  -  Реализация работы макстека: <br />
     [makstak](https://github.com/necha143/algorithms/blob/main/lab3/Makstak.cpp) <br />
  -  Дан массив из n элементов и m запросов: найти первое и последнее вхождение числа в массив. Т.е. бинарный поиск: <br />
     [**bin. search**](https://github.com/necha143/algorithms/blob/main/lab3/bin_search.cpp) <br />
  -  Гирлянда состоит из n лампочек на общем проводе. Один её конец закреплён на заданной высоте A мм (h1 = A). Благодаря силе тяжести гирлянда прогибается: высота каждой неконцевой лампы на 1 мм меньше, чем средняя высота ближайших соседей (hi=(hi-1 + hi+1)/2 -1). Требуется найти минимальную высоту второго конца B (B = hn) при условии, что ни одна из лампочек не должна лежать на земле: <br />
     [Garland](https://github.com/necha143/algorithms/blob/main/lab3/garland.cpp) <br />
  -  Вам задан массив из n натуральных чисел.
Разделите его ровно на k массивов так, чтобы сумма чисел в массиве с самой большой суммой чисел была минимально возможной. <br />
     [Splitting of array](https://github.com/necha143/algorithms/blob/main/lab3/splitting_of_array.cpp) <br />
### **Lab4:**
  -  Дан массив целых чисел. Определите, является ли он неубывающей пирамидой (кучей): <br />
     [heap...?](https://github.com/necha143/algorithms/blob/main/lab4/is_heap.cpp) <br />
  -  Пирамидальная сортировка (сортировка кучей): <br />
     [**heap sort**](https://github.com/necha143/algorithms/blob/main/lab4/heap_sort.cpp) <br />
  -  Реализуйте приоритетную очередь. Очередь должна поддерживать следующие операции: добавить элемент (push x), извлечь минимальный элемент (extract-min), уменьшить элемент (decrease-key x y), добавленный во время одной из операций. <br />
     [priority queue](https://github.com/necha143/algorithms/blob/main/lab4/priority_queue.cpp) <br />
  -  Дано n строк, выведите их порядок после k фаз цифровой сортировки. <br />
     [**radix sort**](https://github.com/necha143/algorithms/blob/main/lab4/radix_sort.cpp) <br />
### **Lab5:**
  - Высотой дерева называется максимальное число вершин дерева в цепочке, начинающейся в корне дерева, заканчивающейся в одном из его листьев, и не содержащей никакую вершину дважды.
    Дано двоичное дерево поиска. В вершинах этого дерева записаны ключи - целые числа, по абсолютному значению не превышающие 10^9
    Найдите высоту данного дерева. <br />
    [height of tree](https://github.com/necha143/algorithms/blob/main/lab5/tree_height.cpp) <br />
 -  Дано двоичное дерево. Проверьте, выполняется ли для него свойство двоичного дерева поиска. <br />
    [correct tree?](https://github.com/necha143/algorithms/blob/main/lab5/correct_tree.cpp) <br />
 -  Дана структура бинарного дерева. Требуется заполнить её числами от 11 до nn так, чтобы получилось корректное бинарное дерево поиска. <br />
    [push tree](https://github.com/necha143/algorithms/blob/main/lab5/push_tree.cpp) <br />
 -  Реализуйте двоичное дерево поиска. Команды: 
      - insert x - добавить в дерево ключ xx.
      - delete x - удалить из дерева ключ xx. Если ключа xx в дереве нет, то ничего делать не надо.
      - exists x - если ключ xx есть в дереве, выведите true, если нет - false.
      - next x - выведите минимальный элемент в дереве, строго больший x, или none если такого. нет
      - prev x - выведите максимальный элемент в дереве, строго меньший xx, или none, если такого нет. <br />
    
    [**binary search tree**](https://github.com/necha143/algorithms/blob/main/lab5/binary_tree.cpp) <br />
 -  Три друга списывают лабораторную работу, каждый из них списывает по nn различных задач. Поскольку друзья не очень умные, они не меняют названия отправляемых на проверку файлов. Правила баллов:
      - если задача написана только у одного студента, то этот студент получает 3 балла, поскольку эту задачу он не списывал и не давал списывать;
      - если задача списана ровно у двух студентов, то каждый из них получает по 1 утешительному баллу;
      - если задача списана всеми тремя студентами, то за нее баллы не начисляются никому. <br />
    
    [three friends](https://github.com/necha143/algorithms/blob/main/lab5/three_friends.cpp) <br />
 -  Рассмотрим два способа обойти бинарное дерево поиска <br />
    - Вывести значение в текущей вершине и затем рекурсивно запустить процедуру обхода от левого и правого потомка.
    - Рекурсивно запустить процедуру обхода от левого и правого потомка и затем вывести значение в текущей вершине. <br />
    
    Требуется по результату обхода первым способом получить результат обхода вторым способом. <br />
    [two ways](https://github.com/necha143/algorithms/blob/main/lab5/two_ways.cpp) <br />
### **Lab6:**
 -  Проверка сбалансированности. 
АВЛ-дерево является сбалансированным в следующем смысле: для любой вершины высота ее левого поддерева отличается от высоты ее правого поддерева не больше, чем на единицу.
Дано двоичное дерево поиска. Для каждой его вершины требуется определить ее баланс. <br />
    [balance](https://github.com/necha143/algorithms_1sem/blob/main/lab6/avl_balance.cpp) <br />
 -  Делаю я левый поворот. 
Для балансировки АВЛ-дерева при операциях вставки и удаления производятся левые и правые повороты. Левый поворот в вершине производится, когда баланс этой вершины больше 1, аналогично, правый поворот производится при балансе, меньшем 1.
Дано дерево, в котором баланс дерева равен 2. Сделайте левый поворот. <br />
    [left rotation](https://github.com/necha143/algorithms_1sem/blob/main/lab6/left_rotation.cpp) <br />
 -  Вставка в АВЛ-дерево. <br />
    [insert in avl](https://github.com/necha143/algorithms_1sem/blob/main/lab6/insert%20in%20avl.cpp) <br />
 -  Три друга 2: возвращение. 
Три друга списывают лабораторную работу, каждый из них списывает по nn различных задач. Поскольку друзья не очень умные, они не меняют названия отправляемых на проверку файлов. <br />
    [three friends](https://github.com/necha143/algorithms_1sem/blob/main/lab6/three_friends2.cpp) <br />
 -  Петя кормит котов. 
Мама подарила мальчику Пете n кошек.
Что бы кошки могли спокойно кушать, Петя завел n мисок для корма. Миска с номером j принадлежит кошке с номером j. Изначально миски пустые. <br />
    [petya and cats](https://github.com/necha143/algorithms_1sem/blob/main/lab6/petya%20and%20cats.cpp) <br />
